#version 460
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=0) uniform samplerCube uEnv;
layout(binding=1, rgba16f) writeonly uniform image2DArray uIrradiance;

// (or compute size from gl_NumWorkGroups)
layout(push_constant) uniform PC {
    uint size; // target face size (e.g., 32)
    uint sampleCount; // e.g., 0.025f (quality vs cost)
} pc;

const float PI = 3.14159265358979323846;

// Cube face UV -> direction
vec3 face_uv_to_dir(uint face, vec2 uv) {
    uv = uv * 2.0 - 1.0; // [0,1] -> [-1,1]
    if (face==0) return normalize(vec3( 1.0, -uv.y, -uv.x)); // +X
    if (face==1) return normalize(vec3(-1.0, -uv.y,  uv.x)); // -X
    if (face==2) return normalize(vec3( uv.x,  1.0,  uv.y)); // +Y
    if (face==3) return normalize(vec3( uv.x, -1.0, -uv.y)); // -Y
    if (face==4) return normalize(vec3( uv.x, -uv.y,  1.0)); // +Z
    return normalize(vec3(-uv.x, -uv.y, -1.0)); // -Z
}

// Radical inverse in base 2 (Van der Corput)
float VanDerCorputBase2(uint i) {
    return bitfieldReverse(i) * 2.3283064365386963e-10;
}

vec2 Hammersley2dSeq(uint i, uint sequenceLength) {
    return vec2(float(i) / float(sequenceLength), VanDerCorputBase2(i));
} 

// Cosine weighted hemisphere sample in tangent space
vec3 sampleCosineHemisphere(vec2 Xi) {
    float phi = 2.0 * PI * Xi.x;
    float r = sqrt(Xi.y); // cosine weighting
    float x = r * cos(phi);
    float y = r * sin(phi);
    float z = sqrt(max(0.0, 1.0 - x*x - y*y));
    return vec3(x, y, z); // z is up (aligned with N in TBN)
}

// Frisvad style orthonormal basis from N
void makeTBN(in vec3 N, out vec3 T, out vec3 B) {
    float sign = N.z >= 0.0 ? 1.0 : -1.0;
    float a = -1.0 / (sign + N.z);
    float b = N.x * N.y * a;
    T = vec3(1.0 + sign * N.x * N.x * a, sign * b, -sign * N.x);
    B = vec3(b, sign + N.y * N.y * a, -N.y);
    T = normalize(T);
    B = normalize(B);
}

// 32 bit float hash -> [0,1)
float hash11(uint x) {
    x ^= 2747636419u; 
    x *= 2654435769u;
    x ^= x >> 16;     
    x *= 2654435769u;
    x ^= x >> 16;
    return float(x) * 2.3283064365386963e-10;
}

float texelSolidAngleBase(uint faceSize0) {
    // Average solid angle per texel of a cubemap at mip 0 (good enough for FIS)
    return (4.0 * PI) / (6.0 * float(faceSize0 * faceSize0));
}

void main() {
    // TODO: Supply these as PCs
    float mipBias = 0.75;
    uint envFaceSize0 = 1024;

    ivec3 gid = ivec3(gl_GlobalInvocationID.xyz);
    if (gid.z >= 6 || gid.x >= int(pc.size) || gid.y >= int(pc.size)) return;

    uint face = gid.z;
    vec2 uv = (vec2(gid.xy) + 0.5) / float(pc.size);

    vec3 N = face_uv_to_dir(face, uv);
    vec3 T, B;
    makeTBN(N, T, B);

    uint seed = uint(gid.x) * 1973u ^ uint(gid.y) * 9277u ^ face * 26699u;
    vec2 rot = vec2(hash11(seed), hash11(seed ^ 0x9E3779B9u));

    vec3 irradiance = vec3(0.0);

    float omega_p0 = texelSolidAngleBase(envFaceSize0);
    float maxMip = float(textureQueryLevels(uEnv) - 1);

    for (uint i = 0u; i < pc.sampleCount; ++i) {
        vec2 Xi = Hammersley2dSeq(i, pc.sampleCount);
        Xi = fract(Xi + rot);
        vec3 H = sampleCosineHemisphere(Xi); // Cosine-weighted sample in tangent space
        vec3 L = normalize(T * H.x + B * H.y + N * H.z); // World-space direction
        float pdf = H.z * (1.0 / PI); // pdf for cosine-weighted hemisphere
        float omega_s = 1.0 / (float(pc.sampleCount) * max(pdf, 1e-6)); // Solid angle represented by this sample
        float lod = 0.5 * log2(omega_s / omega_p0) + mipBias; // Choose mip whose texels roughly match omega_s
        lod = clamp(lod, 0.0, maxMip);
        vec3 samp = textureLod(uEnv, L, lod).rgb;
        irradiance += samp; // NOTE: no extra cos term here
    }

    // Cosine-weighted estimator => multiply by PI/N
    irradiance *= (PI / float(pc.sampleCount));
    imageStore(uIrradiance, gid, vec4(irradiance, 1.0));
}
