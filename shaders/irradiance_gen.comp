#version 460
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=0) uniform samplerCube uEnv;
layout(binding=1, rgba32f) writeonly uniform image2DArray uIrradiance;

// (or compute size from gl_NumWorkGroups)
layout(push_constant) uniform PC {
    uint size; // target face size (e.g., 32)
    uint sampleCount; // e.g., 0.025f (quality vs cost)
} pc;

const float PI = 3.14159265358979323846;

// Cube face UV -> direction
vec3 face_uv_to_dir(uint face, vec2 uv) {
    uv = uv * 2.0 - 1.0; // [0,1] -> [-1,1]
    if (face==0) return normalize(vec3( 1.0, -uv.y, -uv.x)); // +X
    if (face==1) return normalize(vec3(-1.0, -uv.y,  uv.x)); // -X
    if (face==2) return normalize(vec3( uv.x,  1.0,  uv.y)); // +Y
    if (face==3) return normalize(vec3( uv.x, -1.0, -uv.y)); // -Y
    if (face==4) return normalize(vec3( uv.x, -uv.y,  1.0)); // +Z
    return normalize(vec3(-uv.x, -uv.y, -1.0)); // -Z
}

// Radical inverse in base 2 (Van der Corput)
float radicalInverse_VdC(uint bits) {
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 2^32
}

vec2 hammersley(uint i, uint N) {
    return vec2(float(i) / float(N), radicalInverse_VdC(i));
}

// Cosine weighted hemisphere sample in tangent space
vec3 sampleCosineHemisphere(vec2 Xi) {
    float phi = 2.0 * PI * Xi.x;
    float r = sqrt(Xi.y); // cosine weighting
    float x = r * cos(phi);
    float y = r * sin(phi);
    float z = sqrt(max(0.0, 1.0 - x*x - y*y));
    return vec3(x, y, z); // z is up (aligned with N in TBN)
}

// Frisvad style orthonormal basis from N
void makeTBN(in vec3 N, out vec3 T, out vec3 B) {
    float sign = N.z >= 0.0 ? 1.0 : -1.0;
    float a = -1.0 / (sign + N.z);
    float b = N.x * N.y * a;
    T = vec3(1.0 + sign * N.x * N.x * a, sign * b, -sign * N.x);
    B = vec3(b, sign + N.y * N.y * a, -N.y);
    T = normalize(T);
    B = normalize(B);
}

// 32 bit float hash -> [0,1)
float hash11(uint x) {
    x ^= 2747636419u; 
    x *= 2654435769u;
    x ^= x >> 16;     
    x *= 2654435769u;
    x ^= x >> 16;
    return float(x) * 2.3283064365386963e-10;
}

void main() {
    ivec3 gid = ivec3(gl_GlobalInvocationID.xyz);
    if (gid.z >= 6 || gid.x >= int(pc.size) || gid.y >= int(pc.size)) return;

    uint face = gid.z;
    vec2 uv = (vec2(gid.xy) + 0.5) / float(pc.size);

    vec3 N = face_uv_to_dir(face, uv);

    vec3 T, B;
    makeTBN(N, T, B);

    // Per pixel rotation
    uint seed = uint(gid.x) * 1973u ^ uint(gid.y) * 9277u ^ face * 26699u;
    vec2 rot = vec2(hash11(seed), hash11(seed ^ 0x9E3779B9u));

    vec3 irradiance = vec3(0.0);

    for (uint i = 0u; i < pc.sampleCount; ++i) {
        vec2 Xi = hammersley(i, pc.sampleCount);
        Xi = fract(Xi + rot); // Cranley Patterson rotation
        vec3 H = sampleCosineHemisphere(Xi); // tangent space
        vec3 L = normalize(T * H.x + B * H.y + N * H.z); // to world
        irradiance += texture(uEnv, L).rgb;
    }

    irradiance *= (PI / float(pc.sampleCount)); // integral scaling for cosine weighted sampling

    imageStore(uIrradiance, gid, vec4(irradiance, 1.0));
}
