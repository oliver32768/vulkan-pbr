/*
Requires:
- screenDimensions: UBO (vec4)
- numTiles XYZ + tileSizeInPx: UBO (vec4)
- clusterActive[]: SSBO
- Z-Buffer: Sampler2D
- zNear / zFar: PC

- pixelID: Computed using gid
- pixelCoord: Computed using pixelID
- numClusters: Computed using prod(numTiles)
*/

#version 460
layout (local_size_x = 16, local_size_y = 16) in;

layout (std430, set = 0, binding = 0) buffer SSBO_clusterActive {
    uint clusterActiveBits[];
};

layout (set = 0, binding = 1) uniform sampler2D depthTex;

layout (std140, set = 0, binding = 2) uniform UBO_clusterParams {
    mat4 inverseProjection;
    uvec4 tileSizes; // numTiles.xyz, tileSizeInPx.w (square tiles)
    uvec2 screenDimensions;
};

layout (push_constant) uniform constants {
    float zNear;
    float zFar;
} pc;

uint getDepthSlice(float zAbs, uint numSlices, float zNear, float zFar) {
    float nz = max(zAbs, 1e-6);
    float l  = log(zFar / zNear);
    float t  = (log(nz) - log(zNear)) / l;   // [0,1]
    uint s   = uint(floor(t * float(numSlices)));
    return clamp(s, 0u, numSlices - 1u);
}

uint clusterIndex(uvec2 px, float depth) {
    // XY
    uint tileSizeInPx = tileSizes.w;
    uvec2 clusterXY = px / tileSizeInPx;
    uvec2 nXY = tileSizes.xy;

    // Reconstruct view-space position using inverse projection.
    // Vulkan depth is in [0,1]. Put a point on the view ray at this depth.
    //vec4 clip = vec4(0.0, 0.0, depth * 2.0 - 1.0, 1.0); // NDC.z in [-1,1]
    //vec4 clip = vec4(0, 0, depth, 1); // NDC.z in [0,1]

    //vec4 viewPos4 = inverseProjection * clip;
    //vec3 viewPos = viewPos4.xyz / viewPos4.w;
    //float zDist = abs(viewPos.z);

    vec2 ndc;
    ndc.x = ( (float(px.x) + 0.5) / float(screenDimensions.x) ) * 2.0 - 1.0;
    ndc.y = 1.0 - ( (float(px.y) + 0.5) / float(screenDimensions.y) ) * 2.0; // flip Y
    float ndcZ = depth; // Vulkan depth in [0,1]
    vec4 clip  = vec4(ndc, ndcZ, 1.0);
    vec4 view4 = inverseProjection * clip;
    vec3 view  = view4.xyz / view4.w;
    float zDist = abs(view.z);
    uint zSlice = getDepthSlice(zDist, tileSizes.z, pc.zNear, pc.zFar);

    return clusterXY.x + nXY.x * clusterXY.y + (nXY.x * nXY.y) * zSlice;
}

void markActive(uint idx) {
    uint word = idx >> 5; // /32
    uint bit = 1u << (idx & 31u);
    atomicOr(clusterActiveBits[word], bit);
}

void main() {
    uvec2 px = gl_GlobalInvocationID.xy;
    if (px.x >= screenDimensions.x || px.y >= screenDimensions.y) return;

    vec2 uv = (vec2(px) + 0.5) / vec2(screenDimensions);
    float depth = texture(depthTex, uv).r;

    // Skip sky (depth==0)
    if (depth <= 0.0) return;

    uint idx = clusterIndex(px, depth);
    markActive(idx);
}