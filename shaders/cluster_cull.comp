#version 460
layout(local_size_x = 64) in; 

struct Light {
    vec4 pos_radius; // xyz = position (world), w = radius
    vec4 color_intensity; // rgb = color, w = intensity
};

struct LightGrid {
    uint offset; // start into globalLightIndexList
    uint count; // number of lights intersecting this cluster
};

struct VolumeTileAABB {
    vec4 minPoint; // xyz = min (view space)
    vec4 maxPoint; // xyz = max (view space)
};

// All point lights
layout(std430, set = 0, binding = 0) readonly buffer LightsBuf {
    Light lights[];
};

// Cluster AABBs
layout(std430, set = 0, binding = 1) readonly buffer ClusterAABB {
    VolumeTileAABB cluster[];
};

// Unique cluster indices
layout(std430, set = 0, binding = 2) readonly buffer ActiveClusters {
    uint activeClusterIndices[];
};

// Output: flat list of all intersecting light indices for *all* processed clusters
layout(std430, set = 0, binding = 3) buffer LightIndexSSBO {
    uint globalLightIndexList[];
};

// Output: per cluster offset/count into globalLightIndexList
layout(std430, set = 0, binding = 4) buffer LightGridSSBO {
    LightGrid lightGrid[];
};

// Output: global running count for globalLightIndexList (atomically incremented)
layout(std430, set = 0, binding = 5) buffer GlobalIndexCountSSBO {
    uint globalIndexCount;
};

// Small params block (SSBO, not uniform)
layout(std430, set = 0, binding = 6) readonly buffer ParamsBuf {
    mat4 viewMatrix;
    uint lightCount;
    uvec3 _pad;
};

// Input
layout(std430, set = 0, binding = 7) buffer ActiveClusterCountSSBO {
    uint activeClusterCount;
};

// Helpers
bool testSphereAABB(in vec3 centerVS, in float radius, in uint clusterIndex) {
    VolumeTileAABB cell = cluster[clusterIndex];

    float sqDist = 0.0;
    // Clamp point to AABB and accumulate squared distance outside box
    for (int i = 0; i < 3; ++i) {
        float v = centerVS[i];
        float minv = cell.minPoint[i];
        float maxv = cell.maxPoint[i];
        if (v < minv) {
            float d = (minv - v);
            sqDist += d * d;
        } else if (v > maxv) {
            float d = (v - maxv);
            sqDist += d * d;
        }
    }
    return sqDist <= (radius * radius);
}

// Transform to view space if needed
vec3 lightCenterVS(in Light L) {
    return vec3(viewMatrix * vec4(L.pos_radius.xyz, 1.0));
}

shared Light sharedLights[gl_WorkGroupSize.x];

void main() {
    uint gid = gl_GlobalInvocationID.x;
    // replacing the early return because every workgroup must reach barrier() calls
    // selectively masking off work below according to isActive instead
    bool isActive = (gid < activeClusterCount); 

    uint clusterIndex = isActive ? activeClusterIndices[gid] : 0u; // Only read a valid cluster index if active

    const uint MAX_VISIBLE_PER_CLUSTER_PER_THREAD = 128u;
    uint visibleLightIndices[MAX_VISIBLE_PER_CLUSTER_PER_THREAD];
    uint visibleLightCount = 0u;

    uint threadCount = gl_WorkGroupSize.x;
    uint localID = gl_LocalInvocationIndex;
    uint numBatches = (lightCount + threadCount - 1u) / threadCount;

    for (uint batch = 0u; batch < numBatches; ++batch) {
        uint lightIndex = batch * threadCount + localID;

        if (lightIndex < lightCount) {
            sharedLights[localID] = lights[lightIndex];
        }

        barrier(); // Make writes to shared memory visible

        if (isActive) {
            for (uint li = 0u; li < threadCount; ++li) {
                uint idx = batch * threadCount + li;
                if (idx >= lightCount) break;

                Light L = sharedLights[li];

                float radius = L.pos_radius.w;
                if (radius <= 0.0) continue;

                vec3 centerVS = lightCenterVS(L);

                if (testSphereAABB(centerVS, radius, clusterIndex)) {
                    if (visibleLightCount < MAX_VISIBLE_PER_CLUSTER_PER_THREAD) {
                        visibleLightIndices[visibleLightCount++] = idx;
                    }
                }
            }
        }

        barrier(); // Nobody may start overwriting sharedLights for the next batch until all lanes are done reading this batch
    }

    if (isActive) {
        uint offset = atomicAdd(globalIndexCount, visibleLightCount);
        for (uint i = 0u; i < visibleLightCount; ++i) {
            globalLightIndexList[offset + i] = visibleLightIndices[i];
        }
        lightGrid[clusterIndex].offset = offset;
        lightGrid[clusterIndex].count  = visibleLightCount;
    }
}
